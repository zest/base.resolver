<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> zest &#x276d; Source: index.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">zest &#x276d; Source: index.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>'use strict';
/**
 * @fileOverview The base.resolver component provides inversion of control and dependency injection api for running of
 * zest infrastructure components. Using resolver, you set up a simple configuration and tell resolver which components
 * you want to load. Each component registers itself with resolver, so other components can use its functions.
 * Components can be maintained as NPM packages so they can be dropped in to other zest integrations. Simple components
 * can also just be a file that can be required from node. (A javascript file or even a JSON file)
 * @module base-resolver
 * @requires base-resolver/configurations
 * @requires base-resolver/resolution-provider
 * @requires base-resolver/unloader
 * @requires base-resolver/utils
 * @requires q
 */
var q = require('q');
var path = require('path');
var logger = require('base.logger')('RESOLVER');
var resolverFactory = function (configPathOrArray, basePath) {
    // array of configurations
    var args = [
            configPathOrArray,
            basePath
        ],
        configArray = configPathOrArray,
    // base directory relative to which modules should be resolved
        baseDir,
    // resolver that has load, reload and unload functions
        resolver,
    // configurations is initialized here and sent to resolution-provider
        configurations = require('./resolver/configurations')(),
    // unloader is used to inject unload dependency
        unloader = require('./resolver/unloader')(),
        resolutionProvider = require('./resolver/resolution-provider')(
            configurations, unloader
        );
    /**
     * @description The load function runs all starting components in the configuration, injecting all other
     * dependencies required.
     * @returns {q} a Promise that gets resolved with {@link module:base-resolver~Resolver} when the load is
     * executed. This promise is rejected with the error if load execution fails.
     * @memberof module:base-resolver~Resolver
     */
    var load = function () {
        var startupDependencies = configurations.startupDependencies();
        logger.info(startupDependencies.length, 'startup components found. Loading them now.');
        return q.all(
            startupDependencies.map(
                function (dependencyExpression) {
                    return resolutionProvider.resolve(dependencyExpression);
                }
            )
        ).then(
            function () {
                logger.info('all components loaded successfully!');
                return resolver;
            }, function (error) {
                logger.error('error loading startup components!', error);
                throw error;
            }
        );
    };
    /**
     * @description The unload function will call all registered unload handlers and clear off the dependency
     * tree
     * @returns {q} a Promise that gets resolved when the unload is executed. This promise is rejected with the
     * error if unload execution fails.
     * @memberof module:base-resolver~Resolver
     */
    var unload = function () {
        logger.info('unloading components.');
        return unloader.unload().then(
            function () {
                logger.info('successfully unloaded all components!');
            }
        );
    };
    /**
     * The resolver object that is used to start or restart zest integration by taking care of inversion of control
     * and dependency injection.
     * @namespace module:base-resolver~Resolver
     */
    resolver = {
        load: load,
        unload: unload,
        /**
         * The reload function will re-configure and start all starting components in the
         * configuration. If a reload is called before the previous reload is over, the previous reload will be
         * interrupted.
         * @returns {q} a Promise that gets resolved with {@link module:base-resolver~Resolver} when the reload is
         * executed. This promise is rejected with the error if reload execution fails.
         * @memberof module:base-resolver~Resolver
         */
        reload: function () {
            logger.log('reloading components.');
            return unload().then(
                function () {
                    return resolverFactory.apply({}, args);
                }
            ).then(
                function (resolver) {
                    return resolver.load();
                }
            );
        }
    };
    logger.info('initializing resolver with configurations.');
    if (basePath) {
        baseDir = path.resolve(basePath);
    }
    if (typeof configPathOrArray === 'string') {
        try {
            configArray = require(configPathOrArray);
            if (!baseDir) {
                baseDir = path.resolve(path.dirname(configPathOrArray));
            }
        } catch (error) {
            if (error.code !== 'MODULE_NOT_FOUND') {
                logger.error('cannot parse configuration file.');
                logger.error(error);
                throw error;
            }
            configPathOrArray = path.join(process.cwd(), configPathOrArray);
            configArray = require(configPathOrArray);
            if (!baseDir) {
                baseDir = path.dirname(configPathOrArray);
            }
        }
    }
    if (!(configArray instanceof Array)) {
        throw new Error('Resolver can only be configured with an array. Check your configuration');
    }
    if (!baseDir) {
        /*jslint nomen: true */
        baseDir = __dirname;
        /*jslint nomen: false */
    }
    logger.log(baseDir, configArray);
    return configurations.setup(configArray, baseDir).then(
        function () {
            logger.info('initialization successful.');
            return resolver;
        }, function (error) {
            logger.error('error initializing resolver!', error);
            throw error;
        }
    );
};
/**
 * This function configures the resolver. This function takes two parameters and creates a configuration object that is
 * used to load the starting modules.
 * @param {string|Array.&lt;module:base-resolver~Configuration|string>} configPathOrArray - If this parameter is a string,
 * requiring the string path should return the config array. We try to require the &lt;code>configPath&lt;/code> directly. If
 * that fails, it is joined with the current working directory of the process for resolution. The config array itself
 * can also be passed instead of passing a &lt;code>configPath&lt;/code>. if config array element is a string, it is assumed
 * to be the path of the {@link module:base-resolver~Configuration } object, with all other properties defaulted.
 * @param {string} [basePath] -  basePath is an optional parameter which provides the absolute path from where the
 * components should be resolved. If &lt;code>basePath&lt;/code> is not provided, it is resolved as follows:
 * &lt;ul>&lt;li>if the first parameter is a &lt;code>configPath&lt;/code> string, the &lt;code>basePath&lt;/code> is assumed to be the
 * &lt;code>configPath&lt;/code>&lt;/li>
 * &lt;li>if the first parameter is a not a &lt;code>configPath&lt;/code> string, the &lt;code>basePath&lt;/code> is assumed to be the
 * current working directory for the process&lt;/li>&lt;/ul>
 * @returns {q}  a Promise that gets resolved with {@link module:base-resolver~Resolver} when the resolver is set up.
 * This promise is rejected with the error if the resolver set-up fails.
 */
module.exports = function (configPathOrArray, basePath) {
    return q.Promise(
        function (resolve) {
            resolve(resolverFactory(configPathOrArray, basePath));
        }
    );
};
// documenting the Configuration object
/**
 * An array of Configuration object is passed to configure resolver
 * @typedef {object} module:base-resolver~Configuration
 * @property {string} path - specifies the path of the component
 * &lt;ul>&lt;li>if path does not start with a &lt;code>.&lt;/code>, or does not contain &lt;code>/&lt;/code> the component is assumed to
 * be an npm module&lt;/li>
 * &lt;li>if path does not start with a &lt;code>.&lt;/code>, and has a single &lt;code>/&lt;/code>, the component is assumed to be a
 * git repository&lt;/li>
 * &lt;li>in all other cases, the component is assumed to be located at the path specified in the local disk.&lt;/li>&lt;/ul>
 * @property {*} [options] - the options to be passed to instantiate the component.
 * &lt;ul>&lt;li>The Parameter Modifier can be used here using the &lt;code>{param-number}&lt;/code> format&lt;/li>
 * &lt;li>The &lt;code>|&lt;/code> (OR modifier) can also be used to gracefully degrade to defaults (explained in the example
 * below)&lt;/li>
 * &lt;li>If &lt;code>#&lt;/code>, &lt;code>|&lt;/code> or &lt;code>/&lt;/code> are to be used as literals in option, they must be escaped
 * by a &lt;code>/&lt;/code>. Eg. &lt;code>/#&lt;/code> will translate to a single &lt;code>#&lt;/code>&lt;/li>&lt;/ul>
 * @property {boolean} [startup] - startup is optional and is used to specify if a component is a starting component.
 * @property {boolean} [native] - is optional and is used to mark a component as native nodejs module.
 * &lt;ul>&lt;li>Native modules are nodejs modules that are not compliant to the zest component structure&lt;/li>
 * &lt;li>When a component is marked as native, no dependency will be injected in it&lt;/li>
 * &lt;li>A native component can be injected into another component by its module name (as specified in
 * &lt;code>package.json&lt;/code> file&lt;/li>
 * &lt;li>If no &lt;code>package.json&lt;/code> file is found, or if no name is there in &lt;code>package.json&lt;/code>, the native
 * component will be named as the last part of the path in configuration excluding extension.&lt;/li>&lt;/ul>
 */

</code></pre>
        </article>
    </section>




    <footer>
        <a href="http://zest.github.io/base.resolver/">base.resolver</a>  | <a href="http://zest.github.io/base.resolver-cli/">base.resolver-cli</a>  | <a href="http://zest.github.io/base.logger/">base.logger</a>  | <a href="http://zest.github.io/base.gruntrunner/">base.gruntrunner</a>  | <a href="http://zest.github.io/datastore.mongo/">datastore.mongo</a>  | <a href="http://zest.github.io/filestore.disk/">filestore.disk</a>  | <a href="http://zest.github.io/privilege.datastore/">privilege.datastore</a>  | <a href="http://zest.github.io/user.datastore/">user.datastore</a>  | <a href="http://zest.github.io/application.rest/">application.rest</a>  | <a href="http://zest.github.io/integration.embodier/">integration.embodier</a> 
    </footer>
</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-base-resolver.html">base-resolver</a></li><li><a href="configurations.html">base-resolver/configurations</a></li><li><a href="resolution-provider.html">base-resolver/resolution-provider</a></li><li><a href="unloader.html">base-resolver/unloader</a></li><li><a href="utils.html">base-resolver/utils</a></li></ul><h3>Namespaces</h3><ul><li><a href="configurations-ConfigurationManager.html">ConfigurationManager</a></li><li><a href="resolution-provider-ResolutionProvider.html">ResolutionProvider</a></li><li><a href="unloader-Unloader.html">Unloader</a></li><li><a href="module-base-resolver-Resolver.html">Resolver</a></li></ul>
</nav>
<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
