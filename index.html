<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ZEST / base.resolver / Index</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">ZEST / base.resolver / Index</h1>
    
    


    


    <h3> </h3>









    




    <section>
        <article><p><a href="https://david-dm.org/zest/base.resolver#info=dependencies&amp;view=list"><img src="http://img.shields.io/david/zest/base.resolver.svg?style=flat-square" alt="Dependencies"></a>
<a href="https://david-dm.org/zest/base.resolver#info=devDependencies&amp;view=list"><img src="http://img.shields.io/david/dev/zest/base.resolver.svg?style=flat-square" alt="Dev Dependencies"></a>
<a href="https://david-dm.org/zest/base.resolver#info=peerDependencies&amp;view=list"><img src="http://img.shields.io/david/peer/zest/base.resolver.svg?style=flat-square" alt="Peer Dependencies"></a></p>
<p><a href="https://codeclimate.com/github/zest/base.resolver"><img src="http://img.shields.io/codeclimate/github/zest/base.resolver.svg?style=flat-square" alt="Quality"></a>
<a href="https://travis-ci.org/zest/base.resolver"><img src="http://img.shields.io/travis/zest/base.resolver.svg?style=flat-square" alt="Build Status"></a>
<a href="https://coveralls.io/r/zest/base.resolver"><img src="http://img.shields.io/coveralls/zest/base.resolver.svg?style=flat-square" alt="Coverage Status"></a>
<a href="http://unlicense.org"><img src="http://img.shields.io/badge/license-UNLICENSE-brightgreen.svg?style=flat-square" alt="License"></a></p>
<h1>zest / base.resolver</h1>
<blockquote>
<p>The <code>base.resolver</code> component provides inversion of control and dependency injection api for running of zest 
infrastructure components. Using resolver, you set up a simple configuration and tell resolver which components you
want to load. Each component registers itself with resolver, so other components can use its functions. Components
can be maintained as NPM packages so they can be dropped in to other zest integrations. Simple components can also 
just be a file that can be <code>require</code>d from node. (A javascript file or even a JSON file) </p>
</blockquote>
<h2>Component Structure</h2>
<p>For components to be compatible with the resolver, it should export a one of the following:</p>
<ol>
<li><p>When a component exports a <strong>function</strong>, the function acts like a factory function for creation of the component.
The function can either return the component itself, or a <strong>Promise</strong> object that gets resolved with the component
once the component is finished loading. The arguments for the function are injected dynamically by the
<strong>resolver</strong>. For dependency injection to work, the argument names must resolve to a dependency name using the 
<a href="#dependency-name-resolution">dependency name resolution mechanism</a>.</p>
</li>
<li><p>When the component exports an <strong>array with the last element of type function and other elements of type string</strong>, 
the angular style dependency injection mechanism is used. The last element of the array must always be a factory
function whereas, the other arguments must resolve to a dependency name using the
<a href="#dependency-name-resolution">dependency name resolution mechanism</a>. This factory function will be called with
the parameters injected for each of the dependency names in the same sequence. The function can either return the
component itself, or a <strong>Promise</strong> object that gets resolved with the component once the component is finished
loading.</p>
</li>
<li><p>When a component exports <strong>a promise</strong> the value that resolves it is used as the component.</p>
</li>
<li><p>When a component exports <strong>anything other than the above mentioned structures</strong>, the value itself is used to
resolve the component.</p>
</li>
</ol>
<p>Example configurations are shown below:</p>
<p><em>object as a component</em></p>
<pre><code class="lang-js">module.exports = {
    // component as an object
};</code></pre>
<p><em>component as a factory function. Note the parameter names should match dependency names</em></p>
<pre><code class="lang-js">module.exports = function (database, user, options) {
    return {
        // component as an object
    };
};</code></pre>
<p><em>component as an array of dependencies and factory function. Note that parameter names can be anything here. Also, the
user dependency is optional</em></p>
<pre><code class="lang-js">module.exports = [
    'database',
    'user?',
    'options',
    'unload', 
    function (db, user, opt, unload) {
        return {
            // component as an object
        };
    }
];</code></pre>
<p><em>return value as a promise. Any of the above three declaration methods can return a promise instead of an object as 
shown below</em></p>
<pre><code class="lang-js">module.exports = [
    'database',
    'user',
    'options',
    function (db, user, opt) {
        return Q.Promise(function (resolve, reject) {
            // some code
            resolve({
                // component as an object
            });
        });
    }
];</code></pre>
<h3>Naming Modularized Components</h3>
<p>If a component is a node module complete with a package.json file (it need not actually be in npm, it can be a simple
folder in the code tree.), for base.resolver to register this module as a named component that is injectable, a 
<code>zest-component</code> entry must be added to the package.json file of the component.</p>
<p>The package.json structure for the component can be as described:</p>
<pre><code class="lang-js">// package.json
{
    ...
    &quot;zest-component&quot;: &quot;privilege&quot;
    ...
}</code></pre>
<h3>Naming Non-Modularized Components</h3>
<p>Components that are not node modules can be named by setting the <code>zest-component</code> attribute in the returned exports
object. Components that are JSON files can also use the same attribute.</p>
<h3>Un-Named Components</h3>
<p>A component might not have a name. If unnamed, it cannot be injected as a dependency.</p>
<h3>Dependency Name Resolution</h3>
<p>The dependency name resolution mechanism is used to map a string (which can be a dependency name in the array syntax of
component definition or a parameter name in the function syntax of component definition, see
<a href="#component-structure">Component Structure</a>) The resolution follows the below steps:</p>
<h4>Modifiers</h4>
<p>Modifiers are used to add logic to dependency injection. There are 4 kinds of modifiers. They are listed in their order
of execution priority below:</p>
<ul>
<li><strong><code>#</code> (parameter modifier)</strong> will pass parameters to the component that can be used to construct the options object.
 See <a href="#configuring-resolver">Configuring Resolver</a> for more details on parameter usage.</li>
<li><strong><code>!</code> (immediate modifier)</strong> will mark a dependency as immediate. When a dependency is immediate, resolver will not
 wait for it to resolve, but instead, pass a promise ( which will get resolved when the immediate dependency 
 resolves ) to the component factory function. Immediate is discussed in detail in the 
 <a href="#circular-dependencies">Circular Dependencies</a> section.</li>
<li><strong><code>|</code> (OR modifier)</strong> will inject the first resolvable component</li>
<li><strong><code>?</code> (optional modifier)</strong> will silently pass undefined if resolution fails</li>
</ul>
<blockquote>
<p>Modifier usage examples:</p>
<p><code>databaseMongo</code></p>
<ul>
<li>will resolve to databaseMongo if it can be resolved</li>
<li>will throw an error if databaseMongo cannot be resolved</li>
</ul>
<p><code>databaseMongo|databaseSQL</code></p>
<ul>
<li>will resolve to databaseMongo if it can be resolved</li>
<li>will resolve to databaseSQL is databaseMongo cannot be resolved</li>
<li>will throw an error if none of them are resolved</li>
</ul>
<p><code>databaseMongo?</code></p>
<ul>
<li>will resolve to databaseMongo if it can be resolved</li>
<li>will inject <code>undefined</code> if databaseMongo cannot be resolved</li>
</ul>
<p><code>databaseMongo!</code></p>
<ul>
<li>will immediately resolve to databaseMongo if it can be resolved</li>
<li>will throw an error if databaseMongo cannot be resolved immediately</li>
</ul>
<p><code>databaseMongo|databaseSQL?</code></p>
<ul>
<li>will resolve to databaseMongo if it can be resolved</li>
<li>will resolve to databaseSQL if databaseMongo cannot be resolved</li>
<li>will inject <code>undefined</code> if none of them are resolved</li>
</ul>
<p><code>databaseMongo#localhost#9876</code></p>
<ul>
<li>will resolve to databaseMongo replacing <code>#1</code> in options object by <code>localhost</code> and <code>#2</code> in options object by <code>9876</code></li>
<li>will throw an error if databaseMongo cannot be resolved</li>
</ul>
<p><code>databaseMongo#localhost#9876|databaseSQL#localhost#3200?</code></p>
<ul>
<li>will resolve to databaseMongo replacing <code>{1}</code> in options object by <code>localhost</code> and <code>{2}</code> in options object by <code>9876</code>
if it can be resolved</li>
<li>will resolve to databaseSQL  replacing <code>{1}</code> in options object by <code>localhost</code> and <code>{2}</code> in options object by <code>3200</code>
if databaseMongo cannot be resolved</li>
<li>will inject <code>undefined</code> if none of them are resolved</li>
</ul>
</blockquote>
<h4>Name Resolution</h4>
<p>The dependency names are resolved using the below steps:</p>
<ol>
<li><p>If the name matches a component name, the component is injected directly.</p>
<blockquote>
<p>eg. <code>database</code> will get resolved to a component with name <code>database</code> if it exists.</p>
</blockquote>
</li>
<li><p>If <strong><code>[step 1]</code></strong> fails, and factory function style declaration is used, the component name is transformed from 
camel-case to <code>-</code> and <code>.</code> separated, and a resolution is attempted for the transformed names in sequence. The first
resolution is considered.</p>
<blockquote>
<p>eg. <code>databaseMongoLocal</code> will try to resolve to <code>databaseMongoLocal</code>. If there are no components with that name,
<code>database-mongo-local</code> will be tried. If <code>database-mongo-local</code> is also not resolved, <code>database.mongo.local</code> will
be tried. The first resolution will be taken as the value and if none of them resolves, the component will fail
to resolve.</p>
</blockquote>
</li>
<li><p>For all other cases, the resolution fails.</p>
</li>
</ol>
<h3>Explicit Dependencies</h3>
<p>Apart from component dependencies, any component can access the below list of explicit dependencies in the same format
as it accesses component dependencies:</p>
<ol>
<li><p><strong><code>options</code></strong> dependency is used to inject options passed to the component for its initialization. Options for 
components can be passed from the config object to the resolver (described below in the config object section)</p>
</li>
<li><p><strong><code>unload</code></strong> dependency is used to cleanup and garbage collect a component before it is unloaded. This dependency
gets resolved as a function which takes a callback as an argument. When the component is unloaded, all callbacks
registered with unload are called. The callbacks can either return an object or a promise. If a promise is 
returned, the component unload will not be complete unless the individual callbacks are resolved.</p>
</li>
</ol>
<h2>Configuring Resolver</h2>
<p>The base.resolver component can be configured using a JavaScript array. Every element in the array will correspond to a
component configuration.</p>
<ul>
<li>If no options are to be passed on to the component, the path of the component as a string is enough.</li>
<li><p>If options are to be passed, or if other configuration is required, then the component configuration should contain
the following keys:</p>
<ul>
<li><strong><code>path</code></strong> &#8594; specifies the path of the component<ul>
<li>if path does not start with a <code>.</code>, or does not contain <code>/</code> the component is assumed to be an npm module</li>
<li>if path does not start with a ., and has a single /, the component is assumed to be a git repository</li>
<li>in all other cases, the component is assumed to be located at the path specified in the local disk </li>
</ul>
</li>
<li><strong><code>options</code></strong> &#8594; the options to be passed to instantiate the component.<ul>
<li>The <a href="#modifiers">Parameter Modifier</a> can be used here using the <code>{param-number}</code> format</li>
<li>The <code>|</code> (OR modifier) can also be used to gracefully degrade to defaults (explained in the example below)</li>
<li>If <code>#</code>, <code>|</code>, <code>!</code> or <code>/</code> are to be used as literals in option, they must be escaped by a <code>/</code>. Eg. <code>/#</code> will 
translate to a single <code>#</code></li>
</ul>
</li>
<li><strong><code>startup</code></strong> &#8594; is optional and is used to specify if a component is a starting component.</li>
<li><strong><code>native</code></strong> &#8594; is optional and is used to mark a component as native nodejs module.<ul>
<li>Native modules are nodejs modules that are not compliant to the zest component structure</li>
<li>When a component is marked as native, no dependency will be injected in it.</li>
<li>A native component can be injected into another component by its module name (as specified in 
<code>package.json</code> file.</li>
<li>If no <code>package.json</code> file is found, or if no name is there in <code>package.json</code>, the native component will be
named as the last part of the path in configuration excluding extension.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-js">[
    // use an object when options are required
    {
        path: &quot;./application.rest&quot;,
        startup: true,
        options: {
            port: 8080
        }
    }, {
        path: &quot;q&quot;,
        native: true
    }, {
        packagePath: &quot;zest/datastore.mongo&quot;,
        options: {
            // parameters can be injected inside the options using the {param-number}
            // format. The OR modifier | can also be used to degrade to defaults. The
            // below string will evaluate to:
            //      the first parameter passed to get the component if it exists
            //      123.456.789.100 is the first parameter is not there
            host: &quot;{1}|123.456.789.100&quot;
        }
    },

    // if no options or flags are to be passed, only the path is enough
    // if path does not start with a ., the component is assumed 
    // to be an npm module
    &quot;base.specifiations&quot;

    // if path does not start with a ., and has a /, the component
    // is assumed to be a git repository
    &quot;zest/base.logger&quot;,

    // if path starts with a ., it is assumed to be a local path
    &quot;./filestore.disk&quot;,
    &quot;../another-folder/another.component&quot;
]</code></pre>
<h2>The Resolver Functions</h2>
<p><strong><code>base.resolver</code></strong> resolves the component dependencies and is responsible for starting any application built on top of 
them. This component exports a function which returns a Resolver for a given configuration. The function parameters are
described below:</p>
<p><strong><code>base.resolver</code></strong><code>(configPath|configArray, [basePath])</code> &#8594; <code>Resolver</code></p>
<p>The function configures the resolver. This function takes two parameter.</p>
<ul>
<li><strong><code>configPath|configArray</code></strong> If this parameter is a string, requiring the string path should return the config
array. We try to require the <code>configPath</code> directly. If that fails, it is joined with the current working
directory of the process for resolution. The config array itself can also be passed instead of passing a
<code>configPath</code>.</li>
<li><strong><code>basePath</code></strong> basePath is an optional parameter which provides the absolute path from where the components 
should be resolved. If <code>basePath</code> is not provided, it is resolved as follows:<ul>
<li>if the first parameter is a <code>configPath</code> string, the <code>basePath</code> is assumed to be the <code>configPath</code></li>
<li>if the first parameter is a not a <code>configPath</code> string, the <code>basePath</code> is assumed to be the current working
directory for the process</li>
</ul>
</li>
</ul>
<p>This function returns a configured Resolver object. The returned resolver object has the below methods:</p>
<ol>
<li><p><strong><code>load</code></strong><code>()</code> &#8594; <code>Promise</code></p>
<p>The load function runs all starting components in the configuration, injecting all other dependencies required.</p>
<p>This function returns a Promise that gets resolved with the resolver object when the load is executed. This promise
is rejected with the error if load execution fails.</p>
</li>
<li><p><strong><code>unload</code></strong><code>()</code> &#8594; <code>Promise</code></p>
<p>The unload function will call all registered unload handlers and clear off the dependency tree.</p>
<p>This function returns a Promise that gets resolved with the resolver object when the unload is complete. This 
promise is rejected with the error if unload fails.</p>
</li>
<li><p><strong><code>reload</code></strong><code>()</code> &#8594; <code>Promise</code></p>
<p>The reload function will re-configure and start all starting components in the configuration. If a <code>reload</code> is 
called before the previous <code>reload</code> is over, the previous <code>reload</code> will be interrupted.</p>
<p>This function returns a Promise that gets resolved with the resolver object when the reload is complete. This 
promise is rejected with the error if reload fails.</p>
</li>
</ol>
<h2>Circular Dependencies</h2>
<p>Circular Dependencies must always be avoided, but, we realized that most of the times, it is un-avoidable!</p>
<p>If a circular dependency is required, we use the immediate resolution (<code>!</code>) modifier at one place. to break the
deadlock scenario. This is explained in detail below:</p>
<h3>The deadlock scenario</h3>
<p><em>zest config</em></p>
<pre><code class="lang-json">[
    {
        &quot;path&quot;: &quot;circular-component1&quot;,
        &quot;startup&quot;: true
    },
    &quot;circular-component2&quot;
]</code></pre>
<p><em>component 1</em></p>
<pre><code class="lang-js">module.exports = [
    'circular-component2',
    function (c2) {
        console.log('circular-component1.load');
        console.log(c2);
        return 'circular-component1';
    }
];
module.exports['zest-component'] = 'circular-component1';</code></pre>
<p><em>component 2</em></p>
<pre><code class="lang-js">module.exports = [
    'circular-component1',
    function (c1) {
        console.log('circular-component2.load');
        console.log(c1);
        return 'circular-component2';
    }
];
module.exports['zest-component'] = 'circular-component2';</code></pre>
<p>The above zest configuration will never resolve.</p>
<ul>
<li>To load <code>component1</code>, <code>component2</code> is required.</li>
<li>But <code>component2</code> needs <code>component1</code> to be resolved in order to load.</li>
</ul>
<h3>Breaking the deadlock scenario</h3>
<p><em>zest config</em></p>
<pre><code class="lang-json">[
    {
        &quot;path&quot;: &quot;circular-component1&quot;,
        &quot;startup&quot;: true
    },
    &quot;circular-component2&quot;
]</code></pre>
<p><em>component 1</em></p>
<pre><code class="lang-js">module.exports = [
    'circular-component2',
    function (c2) {
        console.log('circular-component1.load');
        console.log(c2);
        return 'circular-component1';
    }
];
module.exports['zest-component'] = 'circular-component1';</code></pre>
<p><em>component 2</em></p>
<pre><code class="lang-js">module.exports = [
    'circular-component1!',
    function (c1) {
        console.log('circular-component2.load');
        c1.promise.then(function (data) {
            console.log(data);
        });
        return 'circular-component2';
    }
];
module.exports['zest-component'] = 'circular-component2';</code></pre>
<p>The above zest configuration will however resolve.</p>
<ul>
<li>To load <code>component1</code>, <code>component2</code> is required.</li>
<li><code>component2</code> needs immediate value of <code>component1</code> in order to load.</li>
<li>Instead of <code>component1</code>, an object will be injected in the <code>component2</code> factory function.</li>
<li>This object will have a property <code>promise</code> which is a Promise that gets resolved when <code>component1</code> is available.</li>
</ul>
<p>So, the sequence of consle logs in this case will be:</p>
<pre><code>circular-component2.load
circular-component1.load
circular-component2
circular-component1</code></pre></article>
    </section>






    <footer>
        <a href="http://zest.github.io/base.resolver/">base.resolver</a>  | <a href="http://zest.github.io/base.resolver-cli/">base.resolver-cli</a>  | <a href="http://zest.github.io/base.logger/">base.logger</a>  | <a href="http://zest.github.io/base.gruntrunner/">base.gruntrunner</a>  | <a href="http://zest.github.io/datastore.mongo/">datastore.mongo</a>  | <a href="http://zest.github.io/filestore.disk/">filestore.disk</a>  | <a href="http://zest.github.io/privilege.datastore/">privilege.datastore</a>  | <a href="http://zest.github.io/user.datastore/">user.datastore</a>  | <a href="http://zest.github.io/application.rest/">application.rest</a>  | <a href="http://zest.github.io/integration.embodier/">integration.embodier</a> 
    </footer>
</div>

<nav>
    <h2><a href="index.html">base.resolver</a></h2><h3>Modules</h3><ul><li><a href="module-base-resolver.html">base-resolver</a></li><li><a href="configurations.html">base-resolver/configurations</a></li><li><a href="resolution-provider.html">base-resolver/resolution-provider</a></li><li><a href="unloader.html">base-resolver/unloader</a></li><li><a href="utils.html">base-resolver/utils</a></li></ul><h3>Externals</h3><ul><li><a href="external-base-logger.html">base-logger</a></li><li><a href="external-q.html">q</a></li></ul><h3>Namespaces</h3><ul><li><a href="configurations-ConfigurationManager.html">ConfigurationManager</a></li><li><a href="resolution-provider-ResolutionProvider.html">ResolutionProvider</a></li><li><a href="unloader-Unloader.html">Unloader</a></li><li><a href="module-base-resolver-Resolver.html">Resolver</a></li></ul>
</nav>
<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>